<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Spelling Bee â€” NYTâ€‘style (Demo)</title>
  <!-- Tailwind for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for inâ€‘browser JSX transform -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body { background: #faf8ef; }
    @keyframes shake { 10% { transform: translateX(-2px); } 30% { transform: translateX(2px);} 50% { transform: translateX(-2px);} 70% { transform: translateX(2px);} 90% { transform: translateX(-1px);} 100% { transform: translateX(0);} }
  </style>
</head>
<body>
  <div id="app" class="min-h-screen w-full flex items-center justify-center p-4"></div>

  <script type="text/babel">
    const { useMemo, useState, useEffect } = React;

    // --- Curated demo puzzles (compact word lists for offline play) ---
    const RAW_PUZZLES = [
      {
        id: "p1",
        center: "n",
        letters: ["n","i","g","a","s","e","r"],
        words: [
          "siren","resin","singer","reins","raise","rain","grain","sing","singe","sang","singeing","reassign","reinsign","ringer","reassigning","insignia","range","ranger","inger","earnings","earning","ranges","grains","gaining","reusing","sainer","saner","sarin","sering","seringas","signer","sinners","sinner","ringer","rings","ringside","raising","raisins","resign","resigns","reinsing","raison","arisen","inane","engine","engines","insane","insaner","eraser","erasers","anserine","ensign","ensigns","inners","inner","sienna","siennas"
        ]
      },
      {
        id: "p2",
        center: "a",
        letters: ["a","l","t","r","c","e","p"],
        words: [
          "alert","alter","lateral","relate","pearl","pealer","parcel","tracer","trace","lateen","plate","palate","apteral","praetor","retrace","carpal","lacerate","parate","parter","ratter","taler","talerap","talerpear","clearer","repeal","peelare","placate","parallax"
        ]
      },
      {
        id: "p3",
        center: "o",
        letters: ["o","m","d","h","r","a","t"],
        words: [
          "motor","tomato","moor","room","rotor","format","aroma","door","mood","root","roam","martoor","mortar","moratoria","road","rood","odor","adoptor","harbor","mortarboard"
        ]
      }
    ];

    // Clean and normalize puzzles
    function normalizePuzzles(list) {
      return list.map(p => {
        const letters = Array.from(new Set(p.letters));
        const center = p.center;
        const words = Array.from(new Set(p.words.map(w => String(w).toLowerCase())))
          .filter(w =>
            w.length >= 4 &&
            w.includes(center) &&
            w.split("").every(c => letters.includes(c))
          )
          .sort();
        return { id: p.id, center, letters, words };
      });
    }

    const PUZZLES = normalizePuzzles(RAW_PUZZLES).filter(p => p.words.length);

    function isPangram(word, letters) {
      const set = new Set(word.split(""));
      return letters.every(l => set.has(l));
    }

    function scoreWord(word, letters) {
      if (word.length === 4) return 1;
      let score = word.length;
      if (isPangram(word, letters)) score += 7;
      return score;
    }

    function computeMaxScore(words, letters) {
      return words.reduce((sum, w) => sum + scoreWord(w, letters), 0);
    }

    function rankFromScore(score, maxScore) {
      const pct = maxScore ? score / maxScore : 0;
      if (pct >= 1) return { label: "Queen Bee", emoji: "ðŸ‘‘" };
      if (pct >= 0.7) return { label: "Genius", emoji: "ðŸ§ " };
      if (pct >= 0.5) return { label: "Amazing", emoji: "âœ¨" };
      if (pct >= 0.35) return { label: "Great", emoji: "ðŸ‘" };
      if (pct >= 0.2) return { label: "Nice", emoji: "ðŸ™‚" };
      if (pct >= 0.1) return { label: "Good", emoji: "ðŸ‘Œ" };
      return { label: "Beginner", emoji: "ðŸ" };
    }

    function shuffle(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function App() {
      // choose a random puzzle each time the page loads
      const [puzzleIndex, setPuzzleIndex] = useState(() => Math.floor(Math.random() * PUZZLES.length));
      const puzzle = PUZZLES[puzzleIndex];

      const [letters, setLetters] = useState(puzzle.letters);
      const [input, setInput] = useState("");
      const [found, setFound] = useState([]);
      const [message, setMessage] = useState("");
      const [shake, setShake] = useState(false);
      const [showList, setShowList] = useState(false);

      const maxScore = useMemo(() => computeMaxScore(puzzle.words, puzzle.letters), [puzzle]);
      const score = useMemo(() => found.reduce((sum, w) => sum + scoreWord(w, puzzle.letters), 0), [found, puzzle]);
      const rank = rankFromScore(score, maxScore);

      useEffect(() => {
        setLetters(puzzle.letters);
        setInput("");
        setFound([]);
        setMessage("");
        setShowList(false);
      }, [puzzleIndex]);

      const center = puzzle.center;
      const outer = useMemo(() => letters.filter(l => l !== center), [letters, center]);

      const submit = () => {
        const word = input.toLowerCase();
        if (word.length < 4) return bump("Too short");
        if (!word.includes(center)) return bump(`Must include '${center.toUpperCase()}'`);
        if (!word.split("").every(c => letters.includes(c))) return bump("Invalid letters");
        if (!puzzle.words.includes(word)) return bump("Not in word list");
        if (found.includes(word)) return bump("Already found");

        setFound(f => [...f, word].sort());
        setInput("");
        setMessage(isPangram(word, puzzle.letters) ? "Pangram! +7" : "Nice!");
      };

      const bump = (msg) => {
        setMessage(msg);
        setShake(true);
        setTimeout(() => setShake(false), 300);
      };

      const onKeyDown = (e) => {
        const key = e.key;
        if (key === "Enter") return submit();
        if (key === "Backspace") return setInput(v => v.slice(0, -1));
        if (key.length === 1 && /^[a-zA-Z]$/.test(key)) {
          const k = key.toLowerCase();
          if (letters.includes(k)) setInput(v => (v + k).slice(0, 24));
        }
      };

      useEffect(() => {
        window.addEventListener("keydown", onKeyDown);
        return () => window.removeEventListener("keydown", onKeyDown);
      });

      const shuffleOuter = () => setLetters([center, ...shuffle(outer)]);

      const copyFound = async () => {
        const text = `Spelling Bee â€” ${found.length} words, ${score} pts\n` + found.join(", ");
        try {
          await navigator.clipboard.writeText(text);
          setMessage("Copied results");
        } catch {
          setMessage("Copy failed");
        }
      };

      return (
        <div className="w-full max-w-xl">
          {/* Header */}
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-2">
              <span className="text-2xl">ðŸ“°</span>
              <h1 className="text-xl font-semibold tracking-tight">Spelling Bee</h1>
            </div>
            <div className="flex items-center gap-2">
              <button
                className="px-3 py-1.5 rounded-xl bg-zinc-900 text-white text-sm hover:opacity-90"
                onClick={() => setPuzzleIndex(i => (i + 1) % PUZZLES.length)}
                title="New puzzle"
              >
                New&nbsp;Puzzle
              </button>
              <button
                className="px-3 py-1.5 rounded-xl border border-zinc-300 text-sm hover:bg-zinc-100"
                onClick={() => setShowList(s => !s)}
                title="Reveal / hide word list"
              >
                {showList ? "Hide List" : "Reveal List"}
              </button>
            </div>
          </div>

          {/* Score / Rank Bar */}
          <div className="rounded-2xl bg-white shadow-sm border border-zinc-200 p-4 mb-4">
            <div className="flex items-center justify-between text-sm">
              <div className="font-medium">Score: {score} / {maxScore}</div>
              <div className="flex items-center gap-2">
                <span className="font-medium">Rank:</span>
                <span className="inline-flex items-center gap-1 px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-900 text-xs font-semibold">
                  <span>{rank.emoji}</span>
                  <span>{rank.label}</span>
                </span>
              </div>
            </div>
            <div className="mt-3 h-2 bg-zinc-100 rounded-full overflow-hidden">
              <div
                className="h-full bg-yellow-400 transition-all"
                style={{ width: `${Math.min(100, (score / (maxScore || 1)) * 100)}%` }}
              />
            </div>
            <div className="mt-3 text-xs text-zinc-500">
              Center letter: <b className="text-zinc-800 uppercase">{center}</b> â€” Use letters: {puzzle.letters.join(" ").toUpperCase()}
            </div>
          </div>

          {/* Main */}
          <div className="grid grid-cols-3 gap-4 items-start">
            <div className="col-span-2 rounded-2xl bg-white shadow-sm border border-zinc-200 p-4">
              {/* Input Row */}
              <div className={\`flex items-center gap-2 \${shake ? "animate-[shake_0.3s]" : ""}\`}>
                <div className="flex-1">
                  <div className="w-full rounded-xl border border-zinc-300 px-3 py-2 text-lg tracking-wide bg-zinc-50">
                    {input ? input.toUpperCase() : <span className="text-zinc-400">Type or tap lettersâ€¦</span>}
                  </div>
                </div>
                <button
                  className="px-3 py-2 rounded-xl bg-zinc-900 text-white text-sm font-medium hover:opacity-90"
                  onClick={submit}
                >
                  Enter
                </button>
              </div>

              {/* Hive */}
              <div className="mt-6 flex items-center justify-center">
                <Hive letters={letters} center={center} onKey={(k) => setInput(v => (v + k).slice(0, 24))} />
              </div>

              {/* Controls */}
              <div className="mt-4 flex items-center justify-between text-sm">
                <div className="flex items-center gap-2">
                  <button className="px-3 py-1.5 rounded-xl border border-zinc-300 hover:bg-zinc-100" onClick={() => setInput("")}>Clear</button>
                  <button className="px-3 py-1.5 rounded-xl border border-zinc-300 hover:bg-zinc-100" onClick={() => setInput(v => v.slice(0, -1))}>Delete</button>
                  <button className="px-3 py-1.5 rounded-xl border border-zinc-300 hover:bg-zinc-100" onClick={shuffleOuter}>Shuffle</button>
                </div>
                <div className="text-zinc-500">{message}</div>
              </div>
            </div>

            {/* Found Words */}
            <div className="col-span-1 rounded-2xl bg-white shadow-sm border border-zinc-200 p-4">
              <div className="flex items-center justify-between">
                <div className="font-semibold">Found ({found.length})</div>
                <div className="flex items-center gap-2 text-xs">
                  <button className="px-2 py-1 rounded-lg border border-zinc-300 hover:bg-zinc-100" onClick={copyFound}>Copy</button>
                  <button className="px-2 py-1 rounded-lg border border-zinc-300 hover:bg-zinc-100" onClick={() => setShowList(s => !s)}>{showList ? "Hide" : "Reveal"}</button>
                </div>
              </div>
              <div className="mt-3 h-[360px] overflow-auto pr-1 text-sm">
                {found.length === 0 && <div className="text-zinc-400">No words yet.</div>}
                {found.map(w => (
                  <div key={w} className="py-1 border-b border-zinc-100 flex items-center justify-between">
                    <span className="tracking-wide">{w.toUpperCase()}</span>
                    <span className="text-zinc-400">{scoreWord(w, puzzle.letters)}</span>
                  </div>
                ))}
                {showList && (
                  <>
                    <div className="mt-3 text-xs uppercase tracking-wider text-zinc-400">All valid</div>
                    {puzzle.words.map(w => (
                      <div key={w} className="py-1 border-b border-zinc-100 flex items-center justify-between">
                        <span className="tracking-wide">{w.toUpperCase()}</span>
                        <span className="text-zinc-400">{scoreWord(w, puzzle.letters)}</span>
                      </div>
                    ))}
                  </>
                )}
              </div>
            </div>
          </div>

          {/* Footer */}
          <div className="mt-4 text-xs text-zinc-500 leading-relaxed">
            Rules: 4+ letters. Must include center letter. Only hive letters allowed. 4â€‘letter = 1pt; 5+ = 1 pt/letter; pangram +7. Tap letters or use your keyboard. This is a fanâ€‘made homage UI for demo purposes; not affiliated with NYT.
          </div>
        </div>
      );
    }

    function Hive({ letters, center, onKey }) {
      const order = useMemo(() => {
        const others = letters.filter(l => l !== center);
        return [
          { pos: "top", l: others[0] },
          { pos: "tr", l: others[1] },
          { pos: "br", l: others[2] },
          { pos: "bottom", l: others[3] },
          { pos: "bl", l: others[4] },
          { pos: "tl", l: others[5] },
        ];
      }, [letters, center]);

      return (
        <div className="relative w-[280px] h-[260px] mx-auto">
          <Hex key={center} label={center} center onClick={() => onKey(center)} style={{ left: 110, top: 95 }} />
          {order.map(o => {
            const coords = posToCoord(o.pos);
            return <Hex key={o.pos} label={o.l} onClick={() => onKey(o.l)} style={coords} />;
          })}
        </div>
      );
    }

    function posToCoord(pos) {
      const map = {
        top: { left: 110, top: 20 },
        tr: { left: 190, top: 58 },
        br: { left: 190, top: 132 },
        bottom: { left: 110, top: 170 },
        bl: { left: 30, top: 132 },
        tl: { left: 30, top: 58 },
      };
      return map[pos] || { left: 0, top: 0 };
    }

    function Hex({ label, center = false, onClick, style }) {
      return (
        <button
          onClick={onClick}
          style={style}
          className={\`absolute w-20 [aspect-ratio:1.15] grid place-items-center text-2xl font-semibold rounded-[8px] transition shadow-sm \${center ? "bg-yellow-400 text-zinc-900" : "bg-zinc-200 text-zinc-800 hover:bg-zinc-300"}\`}
        >
          <span className="select-none uppercase tracking-wide">{label}</span>
        </button>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("app"));
    root.render(<App />);
  </script>
</body>
</html>
